
; BINARY OCTAL HEX COUNTER FOR PAL-1
; BUTTONS 2 TO F WILL SET DELAY TIME
; (F=MOST DELAY, 2 IS LEAST DELAY)
; BUTTON 0 RESETS, BUTTON 1 ENTERS
; SINGLE STEP MODE

; BINARY DISPLAY REQUIRES 2ND RIOT WITH 
; I/O MODULE

; ASSEMBLED USING A65 ASSEMBLER
; https://www.retrotechnology.com/restore/a65c.html
; TO COMPILE IN LINUX (AS PER MARK ABENE)
; ln -s a65.h A65.H ; (OR VICE VERSA)
; gcc -I. -o a65 a65.c a65util.c a65eval.c
; THEN CREATE THE FOLLOWING FILE: ASM65 WITH CONTENTS
; (BE SURE dos2unix IS INSTALLED)
; -----------------------------------------------------
; #!/bin/bash
; ./a65 $1.asm -l $1.lst -o $1.hex 
; srec_cat $1.hex -intel -o $1.mos -MOS_Technologies
; unix2dos $1.mos
; -----------------------------------------------------
; THEN chmod +x ASM65 to make it executable
; THIS SCRIPT PUTS THE FILE INTO PAPER TAPE FORMAT
; IN THE KIM MONITOR, USE THE "L" COMMAND TO LOAD PAPER TAPE
; JUST PAST THE OUTPUT OF YOUR SCRIPT (*.mos) INTO TERMINAL.
; DON'T FORGET TO SET UP YOUR DELAYS.  I USED A 10MS CHAR DELAY
; AND A 250MS LINE DELAY.
                        
; -- Ricky Bryce

; *** BEGIN HEAD ***
SCANDS: EQU $1F1F   ; SCANS THE DISPLAY 
GETKEY: EQU $1F6A   ; GETS VALUE FROM KEYPAD
EXIT:   EQU $1C64   ; EXITS TO KIM MONITOR
PBDD:   EQU $1703   ; DATA DIRECTION FOR REGISTER B (LEDS)
                    ; 0=INPUT, 1=OUTPUT
PBD:    EQU $1702   ; DATA REGISTER B (LEDS)
; *** END HEAD ***

	ORG $0200	; PAL-1 STARTS AT 0200H
; *** INITIALIZE ***
INIT:

        LDA #$FF    ; LOAD A WITH INITIAL DELAY
        STA DLYTIME ; STORE THIS TO DELAYTIME
        LDA #$FF    ; LOAD FF TO ACCUMULATOR
        STA PBDD    ; SET REGISTER B (ALL BITS) TO OUTPUT MODE
        LDA #$00    ; LOAD ACCUMULATOR WITH 0 AGAIN
        STA PBD     ; STORE THIS TO LEDS
        JSR SCANDS  ; SCAN THE DISPLAY
        
INIT2:
        LDA #$00    ; LOAD ZERO TO ACCUMULATOR
        STA $FB     ; CLEAR LEFTMOST DIGITS
        STA $FA     ; CLEAR MIDDLE TWO DIGITS
        STA $F9     ; CLEAR RIGHTMOST DIGITS
        STA HEXCOUNTER ; INITIALIZE HEX COUNTER AT ZERO
        STA OCTCOUNTERL ; INITIALIZE OCTAL LOW COUNTER AT ZERO
        STA OCTCOUNTERH ; INITIALIZE OCTAL HIGH COUNTER AT ZERO
; *** END INITIALIZE ***     

; *** MAIN ROUTINE ***
MAIN:
        
OCTLNYB:  
        LDA OCTCOUNTERL ; LOAD THE LOW OCTAL BYTE
        AND #$0F        ; MASK UPPER BITS
        CMP #$08        ; SEE IF IT'S REACHED 8
        BNE OCTALOK     ; IF NOT, THEN CONTINUE
        LDA OCTCOUNTERL ; RELOAD LOW BYTE
        ADC #$07        ; ADD 7
        STA OCTCOUNTERL ; STORE THE NEW VALUE
OCTHNYB:
        AND #$F0        ; MASK OUT LOWER BITS
        CMP #$80        ; SEE IF IT'S REACHED 80
        BNE OCTALOK     ; IF NOT, THEN CONTINUE
        LDA #$00        ; LOAD A WITH ZERO
        STA OCTCOUNTERL   ; STORE ZERO TO OCTALCOUNTERL
        INC OCTCOUNTERH   ; INCREMENT OCTALCOUNTERH
        
OCTALOK:
        LDA OCTCOUNTERL ; LOAD THE LOW OCTAL BYTE
        STA $FA         ; STORE THIS TO CENTER DISPLAY
        LDA OCTCOUNTERH ; LOAD THE HIGH OCTAL BYTE
        STA $FB         ; STORE THIS TO THE LEFT DISPLAY
        LDA HEXCOUNTER  ; LOAD THE HEX COUNTER
        STA $F9         ; THEN STORE THIS TO RIGHT DIGITS
        STA PBD         ; STORE THIS TO LEDS
        JSR SCANDS      ; SCAN THE DISPLAY
        JSR DELAY       ; RUN THE DELAY ROUTINE
        LDA SINGLESTEP  ; SEE IF SINGLE STOP MODE IS ON
        CMP #$00
        BEQ CONTMAIN    ; CONTINUE MAIN
        JSR SST         ; JUMP TO SINGLE STEP
CONTMAIN:
        INC OCTCOUNTERL ; INCREMENT OCTAL COUNTER LOW
        INC HEXCOUNTER  ; INCREMENT THE HEX COUNTER
        LDA HEXCOUNTER  ; RELOAD HEX COUNTER
        CMP #$00        ; SEE IF IT'S ZERO
        BEQ INIT2       ; IF SO, RE-INITIALIZE ALL REGISTERS
        JMP MAIN        ; BACK TO MAIN
  
; *** END MAIN ROUTINE ***

; *** SINGLE STEP ROUTINE ***
SST:                ; DESTRUCTIVE TO A, AND SETS DELAY TO 50H
                    ; NO ENTRY VARS, BUT SINGLESTEP IS SET
                    ; NO EXIT VARS
        LDA #$80    ; LOAD 70 TO ACCUMULATOR
        STA DLYTIME ; STORE THIS TO DELAY TIME
        JSR SCANDS  ; SCAN THE DISPLAY
        JSR GETKEY  ; CHECK THE KEYS
        CMP #$15    ; SEE IF IT'S ZERO
        BEQ SST  ; IF SO, THEN CLEAR SINGLE STEP
        RTS         ; RETURN FROM SUBROUINTE
; *** END SINGLE STEP ROUTINE ***


; *** BEGIN DELAY ROUTINE ***
DELAY:              ; DELAY ROUTINE (DESTRUCTIVE TO A)
                    ; ENTRY > DLYTIME = AMOUNT OF DELAY
                    ; EXIT > DLYCTR = 0
        LDA DLYTIME ; LOAD DELAYTIME TO ACCUMULATOR
        STA DLYCTR  ; STORE THE DLYTIME TO DLYCTR
DLYLOOP:
        DEC DLYCTR  ; DECREMENTS DLYCTR MEMORY LOCATION
        JSR SCANDS  ; SCAN THE DISPLAY
        JSR CHECKKEY; CHECK FOR NEW DELAY VALUE
        LDA DLYCTR
        CMP #$00
        BNE DLYLOOP ; IF NOT YET ZERO, STAY IN LOOP
        RTS         ; RETURN FROM SUBROUTINE
; *** END DELAY ROUTINE ***       

; *** BEGIN CHECKKEY ROUTINE ***
CHECKKEY:           ; CHECKS KEYPAD ENTRY (DESTRUCTIVE TO A)
                    ; ENTRY > NONE
                    ; EXIT > DLYTIME = KEY ENTRY (IF PRESSED)
        JSR GETKEY  ; GET THE KEYS
        CMP #$01     ; SEE IF THE VALUE IS 1
        BNE NOT1    ; BRANCH TO NOT1
        LDA #$01    ; OTHERWISE, LOAD 1 TO ACCUMULTAOR
        STA SINGLESTEP  ; SET SINGLESTEP MODE
        JMP KEYRET
NOT1:        
        JSR GETKEY  ; GET THE VALUE FROM THE KEYPAD
        CMP #$15    ; #$15 = NO KEY PRESSED
        BEQ KEYRET  ; IF NO KEY PRESSED, RETURN
        CMP #$00    ; CHECK FOR ZERO
        BEQ KEYZERO ; IF ZERO RESET
        CMP #$01    ; SEE IF 1 WAS PRESSED
        BEQ KEYRET  ; IF SO, CON'T CLEAR SINGLE STEP
        LDA #$00    ; LOAD ZERO TO ACCUMULATOR
        STA SINGLESTEP  ; CLEAR SINGLE STEP MODE
        JSR GETKEY  ; A WAS DESTROYED, SO RELOAD KEYS
        ROL A       ; ROTATE LEFT A FEW TIMES TO SLOW THE TIME
        ROL A
        ROL A
        ROL A
        AND #$F0    ; DROP ANY LOWER BITS
        STA DLYTIME ; OTHERWISE STORE NEW VALUE TO DLYTIME
        JMP KEYRET
        
KEYZERO: ; RESET
        LDA #$00    ; LOAD ZERO TO ACCUMULATOR
        STA $FB     ; CLEAR LEFTMOST DIGITS
        STA $FA     ; CLEAR MIDDLE TWO DIGITS
        STA $F9     ; CLEAR RIGHTMOST DIGITS
        STA HEXCOUNTER ; INITIALIZE HEX COUNTER AT ZERO
        STA OCTCOUNTERL ; INITIALIZE OCTAL LOW COUNTER AT ZERO
        STA OCTCOUNTERH ; INITIALIZE OCTAL HIGH COUNTER AT ZERO
KEYRET:
        RTS         ; RETURN FROM SUBROUTINE
; *** END CHECKKEY ROUTINE ***

                    
                    
; *** FOOTER ***
HEXCOUNTER:     DB  00
OCTCOUNTERL:    DB  00
OCTCOUNTERH:    DB  00
DLYTIME:        DB  00
DLYCTR:         DB  00
SINGLESTEP:     DB  00
; *** END FOOTER ***

    END
