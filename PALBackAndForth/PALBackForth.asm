
; BACK AND FORTH FOR PAL-1
; CYLON EFFECT
; (F=MOST DELAY, 0=LEAST DELAY)

; BINARY DISPLAY REQUIRES 2ND RIOT WITH 
; I/O MODULE

; ASSEMBLED USING A65 ASSEMBLER
; https://www.retrotechnology.com/restore/a65c.html
; TO COMPILE IN LINUX (AS PER MARK ABENE)
; ln -s a65.h A65.H ; (OR VICE VERSA)
; gcc -I. -o a65 a65.c a65util.c a65eval.c
; THEN CREATE THE FOLLOWING FILE: ASM65 WITH CONTENTS
; (BE SURE dos2unix IS INSTALLED)
; -----------------------------------------------------
; #!/bin/bash
; ./a65 $1.asm -l $1.lst -o $1.hex 
; srec_cat $1.hex -intel -o $1.mos -MOS_Technologies
; unix2dos $1.mos
; -----------------------------------------------------
; THEN chmod +x ASM65 to make it executable
; THIS SCRIPT PUTS THE FILE INTO PAPER TAPE FORMAT
; IN THE KIM MONITOR, USE THE "L" COMMAND TO LOAD PAPER TAPE
; JUST PAST THE OUTPUT OF YOUR SCRIPT (*.mos) INTO TERMINAL.
; DON'T FORGET TO SET UP YOUR DELAYS.  I USED A 10MS CHAR DELAY
; AND A 250MS LINE DELAY.
                        
; -- Ricky Bryce

; *** BEGIN HEAD ***
SCANDS: EQU $1F1F   ; SCANS THE DISPLAY 
GETKEY: EQU $1F6A   ; GETS VALUE FROM KEYPAD
EXIT:   EQU $1C64   ; EXITS TO KIM MONITOR
PBDD:   EQU $1703   ; DATA DIRECTION FOR REGISTER B (LEDS)
                    ; 0=INPUT, 1=OUTPUT
PBD:    EQU $1702   ; DATA REGISTER B (LEDS)
; *** END HEAD *** 

; *** BEGIN INITIALIZE ***
INIT:
        CLD         ; CLEAR DECIMAL MODE
        CLC         ; CLEAR CARRY FLAG
        LDA #$30    ; LOAD A WITH INITIAL DELAY
        STA DLYTIME ; STORE THIS TO DELAYTIME
        LDA #$FF    ; LOAD FF TO ACCUMULATOR
        STA PBDD    ; SET REGISTER B (ALL BITS) TO OUTPUT MODE
        LDA #$00    ; LOAD ACCUMULATOR WITH 0 AGAIN
        STA PBD     ; STORE THIS TO LEDS
        STA $FB     ; CLEAR DISPLAY
; *** END INITIALIZE ***
MAIN:
        LDA #$01    ; LOAD 1 TO ACCUMULATOR
        STA POSITION ; STORE 1 TO POSITION
        STA PBD     ; WRITE THIS TO LEDS
ROTL:   
        JSR DELAY   ; CALL THE DELAY LOOP
        LDA POSITION    ; RELOAD POSITION
        CLC         ; CLEAR CARRY
        ROL A       ; ARITHMETIC SHIFT LEFT
        STA POSITION    ;STORE THE NEW POSITION
        STA PBD     ; STORE TO LEDS
        CMP #$80    ; SEE IF IT'S REACHED 80
        BNE ROTL    ; IF NOT, KEEP ROTATING
ROTR:
        JSR DELAY   ; CALL THE DELAY ROUTINE
        LDA POSITION    ; LOAD THE POSITION
        CLC         ; CLEAR CARRY
        ROR A       ; LOGICAL SHIFT RIGHT
        STA POSITION    ; STORE THE NEW POSITION
        STA PBD     ; STORE TO LEDS
        CMP #$01    ; SEE IF IT'S 1 YET
        BNE ROTR    ; IF NOT, ROTATE RIGHT
        JMP MAIN    ; JUMP TO MAIN
 
; *** MAIN ROUTINE ***


; *** END MAIN ROUTINE ***

; *** BEGIN DELAY ROUTINE ***
DELAY:              ; DELAY ROUTINE (DESTRUCTIVE TO A)
                    ; ENTRY > DLYTIME = AMOUNT OF DELAY
                    ; EXIT > DLYCTR = 0
        LDA DLYTIME    ;LDA DLYTIME ; LOAD DELAYTIME TO ACCUMULATOR
        STA DLYCTR  ; STORE THE DLYTIME TO DLYCTR
        STA $F9     ; STORE THE DELAYTIME TO RIGHTMOST DISPLAY
DLYLOOP:
        JSR CHECKKEY    ; CHECK THE KEYS
        DEC DLYCTR  ; DECREMENTS DLYCTR MEMORY LOCATION
        LDA DLYCTR
        STA $FA
        JSR SCANDS
        LDA DLYCTR
        CMP #$00
        BNE DLYLOOP ; IF NOT YET ZERO, STAY IN LOOP
        RTS         ; RETURN FROM SUBROUTINE
; *** END DELAY ROUTINE ***       

; *** BEGIN CHECKKEY ROUTINE ***
CHECKKEY:           ; CHECKS KEYPAD ENTRY (DESTRUCTIVE TO A)
                    ; ENTRY > NONE
                    ; EXIT > DLYTIME = KEY ENTRY (IF PRESSED)     
        JSR GETKEY  ; GET THE VALUE FROM THE KEYPAD
        CMP #$15    ; #$15 = NO KEY PRESSED
        BEQ KEYRET  ; IF NO KEY PRESSED, RETURN
        STA DLYTIME ; STORE THE DELAYTIME
        CMP #$00    ; CHECK FOR KEY 0
        BNE SETTIME ; IF NOT ZERO SET THE TIME
        LDA #$01    ; OTHERWISE, LOAD A 10
        STA DLYTIME
        JMP KEYRET
SETTIME:
        LDA DLYTIME ; LOAD THE DELAYTIME
        ROL A       ; ROTATE LEFT A FEW TIMES TO SLOW THE TIME
        ROL A
        ;ROL A
        ;ROL A
        AND #$FC    ; DROP ANY LOWER BITS FROM PREVIOUS CARRY
        STA DLYTIME ; OTHERWISE STORE NEW VALUE TO DLYTIME
        JMP KEYRET

KEYRET:
        RTS         ; RETURN FROM SUBROUTINE
        
; *** END CHECKKEY ROUTINE ***

; *** FOOTER ***
DLYTIME:        DB  $00
DLYCTR:         DB  $00
POSITION:       DB  $00
; *** END FOOTER ***

    END
